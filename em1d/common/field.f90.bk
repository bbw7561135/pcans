module field

  implicit none

  private

  public :: field__fdtd_i, field__cip

contains
  
  subroutine field__fdtd_i(uf,up,gp,np,nx,nsp,np2,q,c,delx,delt,bc)

!*********************************************
! Implicit EM field solver
!   gfac    : implicit factor
!              gfac < 0.5 : unstable
!              gfac = 0.5 : no implicit
!              gfac = 1.0 : full implicit
!*********************************************
    use boundary, only : boundary__field, boundary__curre,  boundary__particle

    integer, intent(in)    :: np, nx, nsp, bc
    integer, intent(in)    :: np2(1:nx+bc,nsp)
    real(8), intent(in)    :: q(nsp), c, delx, delt
    real(8), intent(in)    :: gp(4,np,1:nx+bc,nsp)
    real(8), intent(inout) :: up(4,np,1:nx+bc,nsp)
    real(8), intent(inout) :: uf(6,0:nx+1)
    integer                    :: ii, i, isp
    integer, save              :: flag
    integer                    :: np3(1:nx+bc,nsp)
    real(8), parameter         :: gfac=0.505
    real(8)                    :: uj(3,0:nx+1), gkl(6,0:nx+1)
    real(8), save, allocatable :: gf(:,:)
    real(8)                    :: pi, f1, f2, f3, rotb2, rotb3, rote2, rote3

    pi = 4.0*atan(1.0)

    if(flag /= 1)then
       allocate(gf(6,0:nx+1))
       gf(1:3,0:nx+1) = 0.0
       flag = 1
    endif
       
    !position at n+1/2
    do isp=1,nsp
       do i=1,nx+bc
          do ii=1,np2(i,isp)
             up(1,ii,i,isp) = 0.5*(up(1,ii,i,isp)+gp(1,ii,i,isp))
             up(2:4,ii,i,isp) = gp(2:4,ii,i,isp)
          enddo
       enddo
    enddo
    np3(1:nx+bc,1:nsp) = np2(1:nx+bc,1:nsp)

    call boundary__particle(up,np,nx,nsp,np3,bc)
    call ele_cur(uj,up,np,nx,nsp,np3,bc,q,c)
    call boundary__curre(uj,nx,bc)

    !calculation
    !< gk =  (c*delt)*rot(b) - (4*pi*delt)*j >
    !< gl =  (c*delt)*rot(e) >
    f1 = c*delt/delx
    f2 = 4.0*pi*delt

    !By,z
    do i=1,nx
       rote3 = -uf(5,i-1)+uf(5,i)
       rote2 = +uf(6,i-1)-uf(6,i)
       gkl(2,i) = -f1*rote2
       gkl(3,i) = -f1*rote3
    enddo
    !Ex
    do i=1,nx
       gkl(4,i) = -f2*uj(1,i)
    enddo
    !Ey,z
    do i=1,nx+bc
       rotb3 = -uf(2,i)+uf(2,i+1)
       rotb2 = +uf(3,i)-uf(3,i+1)
       gkl(5,i) = f1*rotb2-f2*uj(2,i)
       gkl(6,i) = f1*rotb3-f2*uj(3,i)
    enddo

    call boundary__field(gkl,nx,bc)

    f3 = c*delt*gfac/delx
    do i=1,nx
       gkl(2,i) = gkl(2,i)+f3*(-gkl(6,i-1)+gkl(6,i))
       gkl(3,i) = gkl(3,i)-f3*(-gkl(5,i-1)+gkl(5,i))
    enddo

    !solve  < by & bz;  bx = const >
    call cgm(gf(1:3,0:nx+1),gkl(1:3,0:nx+1),nx,c,delx,delt,gfac,bc)
    call boundary__field(gf,nx,bc)

    !solve  < ex, ey & ez >
    do i=1,nx
       gf(4,i) = gkl(4,i)
    enddo
    do i=1,nx+bc
       gf(5,i) = gkl(5,i)-f3*(-gf(3,i)+gf(3,i+1))
       gf(6,i) = gkl(6,i)+f3*(-gf(2,i)+gf(2,i+1))
    enddo

    call boundary__field(gf,nx,bc)

    !update fields
    uf(1:6,0:nx+1) = uf(1:6,0:nx+1)+gf(1:6,0:nx+1)

    !update particle
    do isp=1,nsp
       do i=1,nx+bc
          do ii=1,np2(i,isp)
             up(1,ii,i,isp) = gp(1,ii,i,isp)
             up(2,ii,i,isp) = gp(2,ii,i,isp)
             up(3,ii,i,isp) = gp(3,ii,i,isp)
             up(4,ii,i,isp) = gp(4,ii,i,isp)
          enddo
       enddo
    enddo

  end subroutine field__fdtd_i


  subroutine field__cip(uf,up,gp,np,nx,nsp,np2,q,c,delx,delt,bc)
!*********************************************
!
! EM field solver by CIP method
!
!*********************************************

    use boundary, only : boundary__field, boundary__curre,  boundary__particle

    integer, intent(in)    :: np, nx, nsp, bc
    integer, intent(in)    :: np2(1:nx+bc,nsp)
    real(8), intent(in)    :: q(nsp), c, delx, delt
    real(8), intent(in)    :: gp(4,np,1:nx+bc,nsp)
    real(8), intent(inout) :: up(4,np,1:nx+bc,nsp)
    real(8), intent(inout) :: uf(6,0:nx+1)
    integer                    :: ii, i, isp, iup
    integer, save              :: iflag
    integer                    :: np3(1:nx+bc,nsp)
    real(8), parameter         :: eps=1d-3
    real(8), allocatable, save :: duf(:,:)
    real(8)                    :: uj(3,0:nx+1)
    real(8)                    :: gf(6,0:nx+1)
    real(8)                    :: dgf(6,0:nx+1)
    real(8)                    :: d2, d, di, dl, tmp, tmp2, ab, sx, c1, c2, c3, alpha, beta, dS, fac
    real(8)                    :: pi

    pi = 4.0*atan(1.0)

    !position at n+1/2
    do isp=1,nsp
       do i=1,nx+bc
          do ii=1,np2(i,isp)
             up(1,ii,i,isp) = 0.5*(up(1,ii,i,isp)+gp(1,ii,i,isp))
             up(2:4,ii,i,isp) = gp(2:4,ii,i,isp)
          enddo
       enddo
    enddo
    np3(1:nx+bc,1:nsp) = np2(1:nx+bc,1:nsp)
    call boundary__particle(up,np,nx,nsp,np3,bc)
    call ele_cur_cip(uj,up,np,nx,nsp,np3,bc,q,c)
    call boundary__curre(uj,nx,bc)

    !convert from E and B to Ex+-By and Ey+-Bx
    uf(5,0:nx+1) = uf(5,0:nx+1)+uf(3,0:nx+1)     !Ey+Bz
    uf(3,0:nx+1) = uf(5,0:nx+1)-2.0*uf(3,0:nx+1) !Ey-Bz
    uf(6,0:nx+1) = uf(6,0:nx+1)+uf(2,0:nx+1)     !Ez+By
    uf(2,0:nx+1) = uf(6,0:nx+1)-2.0*uf(2,0:nx+1) !Ez-By

    !gradient at t=0
    if(iflag /= 1)then
       allocate(duf(6,0:nx+1))
       do i=1,nx
          duf(2,i) = 0.5*(-uf(2,i-1)+uf(2,i+1))
          duf(3,i) = 0.5*(-uf(3,i-1)+uf(3,i+1))
          duf(5,i) = 0.5*(-uf(5,i-1)+uf(5,i+1))
          duf(6,i) = 0.5*(-uf(6,i-1)+uf(6,i+1))
       enddo
       call boundary__field(duf,nx,bc)
       iflag = 1
    endif

    !+non advective term - first step
    fac = +4.*pi*delt*0.5
    uf(4,1:nx) = uf(4,1:nx)-fac*uj(1,1:nx)
    uf(5,1:nx) = uf(5,1:nx)-fac*uj(2,1:nx)
    uf(3,1:nx) = uf(3,1:nx)-fac*uj(2,1:nx)
    uf(6,1:nx) = uf(6,1:nx)-fac*uj(3,1:nx)
    uf(2,1:nx) = uf(2,1:nx)-fac*uj(3,1:nx)
    !update gradient
    call boundary__field(duf,nx,bc)
    do i=1,nx
       dS = -fac*0.5*(-uj(2,i-1)+uj(2,i+1))
       duf(3,i) = duf(3,i)+dS
       duf(5,i) = duf(5,i)+dS
    enddo
    do i=1,nx
       dS = -fac*0.5*(-uj(3,i-1)+uj(3,i+1))
       duf(2,i) = duf(2,i)+dS
       duf(6,i) = duf(6,i)+dS
    enddo

    call boundary__field(uf,nx,bc)
    call boundary__field(duf,nx,bc)
       
    !set constant
    d2  = 1.D0/(delx*delx)

    !Advection of Ey+Bz
    iup = -1
    d  = dble(iup)*delx
    di = 1./d
    dl = -c*delt
    do i=1,nx
       sx = (uf(5,i+iup)-uf(5,i))*di

       if(duf(5,i+iup)*duf(5,i) < 0)then
          alpha = 1.0
       else
          alpha = 0.0
       endif
       
       tmp = duf(5,i+iup)-sx + 1D-10

       beta = 0.5*(1.+tanh((dabs(tmp)-eps)/(0.1*eps))) &
             *(dabs((sx-duf(5,i))/tmp)-1.0)*di
       ab = alpha*beta

       c3 = ( duf(5,i)-sx+tmp*(1.+ab*d) )*d2
       c2 = sx*ab+(sx-duf(5,i))*di-c3*d
       c1 = duf(5,i)+uf(5,i)*ab

       tmp2 = 1./(1.+ab*dl)

       gf(5,i) = (((c3*dl+c2)*dl+c1)*dl+uf(5,i))*tmp2
       dgf(5,i) = ( ((3.*c3*dl+2.*c2)*dl+c1) &
                     -(((c3*dl+c2)*dl+c1)*dl+uf(5,i))*tmp2*ab )*tmp2
    enddo

    !Advection of Ey-Bz
    iup = +1
    d  = dble(iup)*delx
    di = 1./d
    dl = +c*delt
    do i=1,nx
       sx = (uf(3,i+iup)-uf(3,i))*di

       if(duf(3,i+iup)*duf(3,i) < 0)then
          alpha = 1.0
       else
          alpha = 0.0
       endif
       
       tmp = duf(3,i+iup)-sx + 1D-10
       beta = 0.5*(1.+tanh((dabs(tmp)-eps)/(0.1*eps))) &
             *(dabs((sx-duf(3,i))/tmp)-1.0)*di

       ab = alpha*beta
       
       c3 = ( duf(3,i)-sx+tmp*(1.+ab*d) )*d2
       c2 = sx*ab+(sx-duf(3,i))*di-c3*d
       c1 = duf(3,i)+uf(3,i)*ab

       tmp2 = 1./(1.+ab*dl)

        gf(3,i) = (((c3*dl+c2)*dl+c1)*dl+uf(3,i))*tmp2
       dgf(3,i) = ( ((3.*c3*dl+2.*c2)*dl+c1) &
                     -(((c3*dl+c2)*dl+c1)*dl+uf(3,i))*tmp2*ab )*tmp2
    enddo
    !Advection of Ez+By
    iup = +1
    d  = dble(iup)*delx
    di = 1./d
    dl = +c*delt
    do i=1,nx
       sx = (uf(6,i+iup)-uf(6,i))*di

       if(duf(6,i+iup)*duf(6,i) < 0)then
          alpha = 1.0
       else
          alpha = 0.0
       endif
       
       tmp = duf(6,i+iup)-sx + 1D-10
       beta = 0.5*(1.+tanh((dabs(tmp)-eps)/(0.1*eps))) &
             *(dabs((sx-duf(6,i))/tmp)-1.0)*di

       ab = alpha*beta
       
       c3 = ( duf(6,i)-sx+tmp*(1.+ab*d) )*d2
       c2 = sx*ab+(sx-duf(6,i))*di-c3*d
       c1 = duf(6,i)+uf(6,i)*ab

       tmp2 = 1./(1.+ab*dl)

        gf(6,i) = (((c3*dl+c2)*dl+c1)*dl+uf(6,i))*tmp2
       dgf(6,i) = ( ((3.*c3*dl+2.*c2)*dl+c1) &
                     -(((c3*dl+c2)*dl+c1)*dl+uf(6,i))*tmp2*ab )*tmp2
    enddo
    !Advection of Ez-By
    iup = -1
    d  = dble(iup)*delx
    di = 1./d
    dl = -c*delt
    do i=1,nx
       sx = (uf(2,i+iup)-uf(2,i))*di

       if(duf(2,i+iup)*duf(2,i) < 0)then
          alpha = 1.0
       else
          alpha = 0.0
       endif
       
       tmp = duf(2,i+iup)-sx + 1D-10
       beta = 0.5*(1.+tanh((dabs(tmp)-eps)/(0.1*eps))) &
             *(dabs((sx-duf(2,i))/tmp)-1.0)*di

       ab = alpha*beta
       
       c3 = ( duf(2,i)-sx+tmp*(1.+ab*d) )*d2
       c2 = sx*ab+(sx-duf(2,i))*di-c3*d
       c1 = duf(2,i)+uf(2,i)*ab

       tmp2 = 1./(1.+ab*dl)

       gf(2,i) = (((c3*dl+c2)*dl+c1)*dl+uf(2,i))*tmp2
       dgf(2,i) = ( ((3.*c3*dl+2.*c2)*dl+c1) &
                     -(((c3*dl+c2)*dl+c1)*dl+uf(2,i))*tmp2*ab )*tmp2
    enddo

    !update and convert from Ey+-Bz and Ez+-By to E and B
    !+non advective term
    uf(2,1:nx) = 0.5*(-gf(2,1:nx)+gf(6,1:nx))
    uf(3,1:nx) = 0.5*(-gf(3,1:nx)+gf(5,1:nx))
    uf(4,1:nx) = uf(4,1:nx)-fac*uj(1,1:nx)
    uf(5,1:nx) = 0.5*(+gf(3,1:nx)+gf(5,1:nx))-fac*uj(2,1:nx)
    uf(6,1:nx) = 0.5*(+gf(2,1:nx)+gf(6,1:nx))-fac*uj(3,1:nx)

    !update gradient
    !non-advective term
    do i=1,nx
       dS = -fac*0.5*(-uj(2,i-1)+uj(2,i+1))
       duf(3,i) = dgf(3,i)+dS
       duf(5,i) = dgf(5,i)+dS
    enddo

    do i=1,nx
       dS = -fac*0.5*(-uj(3,i-1)+uj(3,i+1))
       duf(2,i) = dgf(2,i)+dS
       duf(6,i) = dgf(6,i)+dS
    enddo

    call boundary__field(uf,nx,bc)
    call boundary__field(duf,nx,bc)


  end subroutine field__cip


  subroutine ele_cur(uj,up,np,nx,nsp,np2,bc,q,c)

    integer, intent(in)  :: np, nx, nsp, bc
    integer, intent(in)  :: np2(1:nx+bc,nsp)
    real(8), intent(in)  :: q(nsp), c
    real(8), intent(in)  :: up(4,np,1:nx+bc,nsp)
    real(8), intent(out) :: uj(3,0:nx+1)
    integer :: ii, i, isp, ih
    real(8) :: vel(3,0:nx+1,nsp)
    real(8) :: dx, dxm, gam

    !memory clear
    vel(1:3,0:nx+1,1:nsp) = 0.0D0
    uj(1:3,0:nx+1) = 0.0D0

    !caluculate erectric current density
    do isp=1,nsp
       do i=1,nx+bc
          do ii=1,np2(i,isp)
             gam = 1./dsqrt(1.0+(+up(2,ii,i,isp)*up(2,ii,i,isp) &
                                 +up(3,ii,i,isp)*up(3,ii,i,isp) &
                                 +up(4,ii,i,isp)*up(4,ii,i,isp) &
                                )/(c*c))

             dx = up(1,ii,i,isp)-i
             dxm = 1.-dx
             vel(1,i  ,isp) = vel(1,i  ,isp)+up(2,ii,i,isp)*gam*dxm
             vel(1,i+1,isp) = vel(1,i+1,isp)+up(2,ii,i,isp)*gam*dx 

             ih = floor(up(1,ii,i,isp)+0.5)
             dx = up(1,ii,i,isp)+0.5-ih
             dxm = 1.-dx

             vel(2,ih-1,isp) = vel(2,ih-1,isp)+up(3,ii,i,isp)*gam*dxm
             vel(2,ih  ,isp) = vel(2,ih  ,isp)+up(3,ii,i,isp)*gam*dx 

             vel(3,ih-1,isp) = vel(3,ih-1,isp)+up(4,ii,i,isp)*gam*dxm
             vel(3,ih  ,isp) = vel(3,ih  ,isp)+up(4,ii,i,isp)*gam*dx 
          enddo
       enddo
    enddo

    do isp=1,nsp
       uj(1:3,0:nx+1) = uj(1:3,0:nx+1)+vel(1:3,0:nx+1,isp)*q(isp)
    enddo

  end subroutine ele_cur


  subroutine ele_cur_cip(uj,up,np,nx,nsp,np2,bc,q,c)

    integer, intent(in)  :: np, nx, nsp, bc
    integer, intent(in)  :: np2(1:nx+bc,nsp)
    real(8), intent(in)  :: q(nsp), c
    real(8), intent(in)  :: up(4,np,1:nx+bc,nsp)
    real(8), intent(out) :: uj(3,0:nx+1)
    integer :: ii, i, isp
    real(8) :: vel(3,0:nx+1,nsp)
    real(8) :: dx, dxm, gam

    !memory clear
    vel(1:3,0:nx+1,1:nsp) = 0.0D0
    uj(1:3,0:nx+1) = 0.0D0

    !caluculate erectric current density
    do isp=1,nsp
       do i=1,nx+bc
          do ii=1,np2(i,isp)
             gam = 1./dsqrt(1.0+(+up(2,ii,i,isp)*up(2,ii,i,isp) &
                                 +up(3,ii,i,isp)*up(3,ii,i,isp) &
                                 +up(4,ii,i,isp)*up(4,ii,i,isp) &
                                )/(c*c))

             dx = up(1,ii,i,isp)-i
             dxm = 1.-dx

             vel(1,i  ,isp) = vel(1,i,  isp)+up(1,ii,i,isp)*gam*dxm
             vel(2,i  ,isp) = vel(2,i,  isp)+up(2,ii,i,isp)*gam*dxm
             vel(3,i,  isp) = vel(3,i,  isp)+up(3,ii,i,isp)*gam*dxm

             vel(1,i+1,isp) = vel(1,i+1,isp)+up(1,ii,i,isp)*gam*dx 
             vel(2,i+1,isp) = vel(2,i+1,isp)+up(2,ii,i,isp)*gam*dx 
             vel(3,i+1,isp) = vel(3,i+1,isp)+up(3,ii,i,isp)*gam*dx 
          enddo
       enddo
    enddo

    do isp=1,nsp
       uj(1:3,0:nx+1) = uj(1:3,0:nx+1)+vel(1:3,0:nx+1,isp)*q(isp)
    enddo

  end subroutine ele_cur_cip


  subroutine cgm(gb,gl,nx,c,delx,delt,gfac,bc)

    !-----------------------------------------------------------------------
    !  #  conjugate gradient method 
    !-----------------------------------------------------------------------

    integer, intent(in)    :: nx, bc
    real(8), intent(in)    :: c, delx, delt, gfac
    real(8), intent(in)    :: gl(3,0:nx+1)
    real(8), intent(inout) :: gb(3,0:nx+1)
    integer :: ite_max = 100 ! maximum number of interation
    integer :: i, l, ite
    real(8) :: err = 1d-6 
    real(8) :: f1, f2, eps, sumr, sum, sum1, sum2, av, bv
    real(8) :: x(0:nx+1), b(0:nx+1), r(0:nx+1), p(0:nx+1), ap(0:nx+1)


    do l=2,3

       ! initial guess
       ite = 0
       f1 = 2.0+(delx/(c*delt*gfac))**2
       f2 = (delx/(c*delt*gfac))**2
       sum = 0.0
       do i=1,nx
          x(i) = gb(l,i)
          b(i) = f2*gl(l,i)
          sum = sum+b(i)*b(i)
       enddo
       eps = dsqrt(sum)*err
       
       if(bc == 0)then
          !periodic condition
          x(0)    = x(nx)
          x(nx+1) = x(1)
       else if(bc == -1)then
          !bounded condition
          x(0)  = x(2)
          x(nx+1) = x(nx-1)
       else
          write(*,*)'choose bc=0 (periodic) or bc=-1 (bounded)'
       endif

       do i=1,nx
          r(i) = b(i)+x(i-1)-f1*x(i)+x(i+1)
          p(i) = r(i)
          sumr = sumr+r(i)*r(i)
       enddo

       if(dsqrt(sumr) > eps)then
       
          do while(sum > eps)
             
             ite = ite+1

             if(bc == 0)then
                !periodic condition
                p(0)    = p(nx)
                p(nx+1) = p(1)
             else if(bc == -1)then
                !bounded condition
                p(0)  = p(2)
                p(nx+1) = p(nx-1)
             else
                write(*,*)'choose bc=0 (periodic) or bc=-1 (bounded)'
                stop
             endif
       
             do i=1,nx
                ap(i) = -p(i-1)+f1*p(i)-p(i+1)
             enddo
             sumr = 0.0
             sum2 = 0.0
             do i=1,nx
                sumr = sumr+r(i)*r(i)
                sum2 = sum2+p(i)*ap(i)
             enddo
             av = sumr/sum2
             
             x(1:nx) = x(1:nx)+av*p(1:nx)
             r(1:nx) = r(1:nx)-av*ap(1:nx)
             
             sum = dsqrt(sumr)
             if(ite >= ite_max) then
                write(6,*)'********** stop at cgm after ite_max **********'
                stop
             endif
             
             sum1 = 0.0
             do i=1,nx
                sum1 = sum1+r(i)*r(i)
             end do
             bv = sum1/sumr
             
             p(1:nx) = r(1:nx)+bv*p(1:nx)
             
          enddo
       endif

       gb(l,1:nx) = x(1:nx)

    end do
    
  end subroutine cgm


end module field
